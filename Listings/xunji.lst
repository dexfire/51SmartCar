C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 17:51:44 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE XUNJI
OBJECT MODULE PLACED IN .\Objects\xunji.obj
COMPILER INVOKED BY: D:\Software\Keil_v5\C51\BIN\C51.EXE xunji.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\xunji.lst) TABS(2) OBJECT(.\Objects\xunji.obj)

line level    source

   1          //#include "oled.h"
   2          //#include "bmp.h"
   3          #include "xunji.h"
   4          //#include "eeprom.h"
   5          #include <REG52.H>
   6          
   7          unsigned char time = 0;
   8          unsigned char pro_left=0,pro_right=0;
   9          struct time_config *current_time_config;
  10          unsigned char code segdata[]= {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f/*,0x77,0x7c,0x39,0x5e,0x7
             -9,0x71*/};
  11          unsigned char display;
  12          code struct time_config speed_level_configs[] = {
  13            
  14            // /* 单独一个轮子拐弯可能拖不动 */
  15          
  16            // // Mode 1
  17            // // 完全跟线走，稍慢, 表现良好
  18            // // 6T 模式下动不了 
  19            // { 65536 - 200, 5,5,  3,5,2,5,  5,3,5,2,  12500,12000 },
  20          
  21            // // Mode 2
  22            // // 完全根线，小弯大弯表现良好，修复能力强，表现优秀
  23            // { 65536 - 200, 6,6,  3,6,2,6, 6,3,6,2,12500,12000 },
  24          
  25            // // Mode 3
  26            // // 大弯修复能力弱，走着走着就偏了
  27            // //{6,6,  1,5,0,5, 5,1,5,0,12000,12000 },
  28            // // 尝试减小偏转力度
  29            // { 65536 - 200,6,6,  1,4,0,4, 4,1,4,0,12000,12000 },
  30          
  31            // // Mode 4
  32            // // 6T 模式下工作良好，表现很好   12T 也还可以
  33            // { 65536 - 200,9,9,  3,5,0,5, 5,3,5,0,12000,12000 },
  34          
  35            // // Mode 5
  36            // // 高速，拐弯溢出边界
  37            // //{15,15,  2,7,1,7, 7,2,7,1,12000,12000 },
  38            // // 尝试再次降低修正幅度   效果还可以   稳定性差
  39            // { 65536 - 200,13,13,  5,7,3,7, 7,5,7,3,12000,12000 },
  40          
  41              /* 单独一个轮子拐弯可能拖不动 */
  42          
  43            // 0
  44            // 完全跟线走，稍慢, 表现良好
  45            // 6T 模式下动不了 
  46            
  47          
  48            // 1
  49            // 完全根线，小弯大弯表现良好，修复能力强，表现优秀
  50            {5,5,  1,5,0,5, 5,1,5,0 , 12000,12000 },
  51            {10,10,  4,10,2,10, 10,4,10,2,  12000,12000 },
  52            // 2
  53            // 大弯修复能力弱，走着走着就偏了
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 17:51:44 PAGE 2   

  54            //{6,6,  1,5,0,5, 5,1,5,0,12000,12000 },
  55            // 尝试减小偏转力度
  56            {10,10,  3,10,0,10, 10,3,10,0,12000,12000 },
  57          
  58            // 3
  59            // 6T 模式下工作良好，表现很好   12T 也还可以
  60            {9,9,  0,4,0,5, 4,0,5,0, 12000,12000 },
  61          
  62            // 4
  63            // 尝试再次降低修正幅度   效果还可以   稳定性差
  64            {13,13,  4,7,2,7, 7,4,7,2,12000,12000 },
  65            
  66            // 5
  67            {6,6,  1,5,1,6, 5,1,6,1,  12000,12000 },
  68          
  69            // 6
  70            {7,6,  1,5,0,7, 5,1,7,0,  12000,12000 },
  71          
  72            // 7
  73            {9,9,  2,10,1,10, 10,2,10,1,  12000,12000 },
  74            
  75            // 8
  76            // 失败的  63 51 
  77            {9,9,  1,5,1,5, 5,1,6,1,  12000,12000 },
  78            
  79            // 9
  80            {12,11,  3,11,1,10, 11,3,10,1,  12000,12000 },
  81            
  82            // 10
  83            { 22,20,  6,22,2,20,22,6,20,2,11000,11500},
  84            
  85            // 11
  86            { 10,10,  3,10,1,10,  10,3,10,1,  11000,11500 },
  87            
  88            // 12
  89            
  90            { 14,14,  4,14,1,10,  14,4,10,1,  11000,11500 }
  91          };
  92          
  93          code struct schdule_config schdule_configs[] = {
  94          {10,11},  
  95          {10,9},
  96          {10,12},
  97          {9,2},
  98            {1,1},  //0 稳 慢
  99            {2,1},  //1 很好
 100            {2,2},
 101            {5,1},  //2 好
 102            {6,1},  // 好 快
 103            {7,1},  // 4
 104            {8,1},
 105            {8,2},
 106            {9,1},  // 7
 107            {9,2},  // 8
 108            
 109            // 不稳定配置
 110          };
 111          
 112          unsigned char turn_configs[] = {
 113            // 比赛顺序
 114            LEFT,RIGHT,STRAIGHT,RIGHT,LEFT
 115          //  RIGHT,
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 17:51:44 PAGE 3   

 116          //  LEFT,
 117          //  LEFT,
 118          //  RIGHT
 119          };
 120          
 121          unsigned char current_time_config_index = 0;
 122          unsigned char current_schdule_config = 0;
 123          unsigned char current_turn_config = 0;
 124          unsigned char mode_low = 1;
 125          unsigned char mode_high = 2;
 126          unsigned int tune_time = 0;
 127          unsigned int runtime = 0;
 128          unsigned int left_steps=0,right_steps=0;
 129          
 130          void delay(int i)      //12M   i=500,t=500ms
 131          {
 132   1        unsigned char j;
 133   1        for( ;i>0;i--)
 134   1          for(j=220;j>0;j--);
 135   1      }
 136          
 137          char key_scan(void)    //按键扫描
 138          {
 139   1        C0=0;
 140   1        delay(1);
 141   1        if(!(R0&&R1&&R2)){BUZZER=0;delay(10);} 
 142   1        if(!(R0&&R1&&R2))
 143   1        {
 144   2          if(!R0) {while(!R0);BUZZER=1;return 1;}
 145   2          if(!R1) {while(!R1);BUZZER=1;return 2;}
 146   2          if(!R2) {while(!R2);BUZZER=1;return 3;}
 147   2        }
 148   1        C0=1;
 149   1        
 150   1        C1=0;
 151   1        delay(1);
 152   1        if(!(R0&&R1&&R2)) delay(10);
 153   1        if(!(R0&&R1&&R2))
 154   1        {
 155   2          if(!R0) {while(!R0);BUZZER=1;return 4;}
 156   2          if(!R1) {while(!R1);BUZZER=1;return 5;}
 157   2          if(!R2) {while(!R2);BUZZER=1;return 6;}
 158   2        }
 159   1        C1=1;
 160   1        
 161   1        C2=0;
 162   1        delay(1);
 163   1        if(!(R0&&R1&&R2)) delay(10);
 164   1        if(!(R0&&R1&&R2))
 165   1        {
 166   2          if(!R0) {while(!R0);BUZZER=1;return 7;}
 167   2          if(!R1) {while(!R1);BUZZER=1;return 8;}
 168   2          if(!R2) {while(!R2);BUZZER=1;return 9;}
 169   2        }
 170   1        C2=1;
 171   1        
 172   1        return 0;
 173   1      }
 174          
 175          void key_control()
 176          {
 177   1        switch(key_scan()) 
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 17:51:44 PAGE 4   

 178   1          {
 179   2            case 1:
 180   2              set_display(current_time_config_index);
 181   2              break;
 182   2      
 183   2            case 2:
 184   2              set_display(current_turn_config);
 185   2              break;
 186   2            
 187   2            case 3:
 188   2              set_display(tune_time);
 189   2              break;
 190   2      
 191   2            case 8:        //换模式
 192   2            {
 193   3              // // 循环切换速度
 194   3              // current_time_config_index++;
 195   3              // if(current_time_config_index>=sizeof(speed_level_configs)/sizeof(struct time_config))
 196   3              //  current_time_config_index = 0;
 197   3              // load_time_config(current_time_config_index);
 198   3              current_schdule_config++;
 199   3              if(current_schdule_config>=sizeof(schdule_configs)/sizeof(struct schdule_config)){
 200   4                current_schdule_config = 0;
 201   4              }
 202   3              set_display(current_schdule_config);
 203   3              mode_low = schdule_configs[current_schdule_config].adjust_time_config;
 204   3              mode_high = schdule_configs[current_schdule_config].straight_time_config;
 205   3              break;
 206   3              // page--;
 207   3              // if(page<1) page=1;
 208   3              // set_display(page);
 209   3              // break;
 210   3            }
 211   2            // 开始、暂停、继续
 212   2            case 9:
 213   2            {
 214   3              TR0 = !TR0; 
 215   3              TR1 = TR0; 
 216   3              set_display(TR0*(current_time_config_index));
 217   3              IN1_1 = 0;
 218   3              IN1_2 = 0;
 219   3              IN2_1 = 0;
 220   3              IN2_2 = 0;
 221   3              tune_time = 0;
 222   3              runtime = 0;
 223   3              break;
 224   3            }
 225   2          }
 226   1      }
 227          
 228          
 229          void init()
 230          {
 231   1        EA=1;
 232   1        TMOD=0x11;      //配置为定时器0 8位重装模式，定时器1为16位定时器
 233   1        
 234   1        TH0=(65536-TIMER0)/256;                 //12M，定时50us
 235   1        TL0=(65536-TIMER0)%256;
 236   1        ET0=1;
 237   1        TR0=0;
 238   1      
 239   1        TH1=(65536-2000)/256;                 //12M，定时2ms
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 17:51:44 PAGE 5   

 240   1        TL1=(65536-2000)%256;
 241   1        ET1=1;
 242   1        TR1=0;
 243   1        
 244   1        // T2CON = 0;  //0000 0000   ;定时器2配置为16位自动重装定时器
 245   1        // RCAP2H = _iror_(65536-250,8);
 246   1        // RCAP2L = 65536-250;
 247   1        // TH2 = _iror_(65536-250,8);
 248   1        // TL2 = 65536-250;
 249   1        // ET2 = 1;
 250   1        // TR2 = 0;
 251   1        
 252   1        TRIG = 0;
 253   1        ECHO = 1;
 254   1        SIG1 = 0;
 255   1        BUZZER = 1;
 256   1        IN1_1 = 0;
 257   1        IN1_2 = 0;
 258   1        IN2_1 = 0;
 259   1        IN2_2 = 0;
 260   1        current_time_config = &speed_level_configs[0];
 261   1        mode_low = schdule_configs[current_schdule_config].adjust_time_config;
 262   1        mode_high = schdule_configs[current_schdule_config].straight_time_config;
 263   1        //eeprom_init();
 264   1        set_display(0);
 265   1      }
 266          
 267          void straight() //走直线
 268          {
 269   1        // 切换配置
 270   1        // 由于比较耗时，所以判断一下当前模式是值得的
 271   1        if(runtime > tune_time){
 272   2          if(current_time_config_index!=mode_high){
 273   3      
 274   3          }
 275   2            load_time_config(mode_high);
 276   2        }
 277   1        pro_left  = (*current_time_config).lstraight;
 278   1        pro_right = (*current_time_config).rstraight;
 279   1      }
 280          
 281          void turn_left() //左修正
 282          {
 283   1      
 284   1      //  pro_left  = (*current_time_config).lturn_left;
 285   1      //  pro_right = (*current_time_config).rturn_left;
 286   1      //  
 287   1        if((runtime>tune_time)&&(current_time_config_index!=mode_low)){
 288   2          load_time_config(mode_low);
 289   2          
 290   2          tune_time = runtime + ADJUST_TIME_SHORT;
 291   2        }else{
 292   2          pro_left  = (*current_time_config).lturn_left;
 293   2          pro_right = (*current_time_config).rturn_left;
 294   2        }
 295   1      }
 296          
 297          void turn_right() //右修正
 298          {
 299   1      //  pro_left  = (*current_time_config).lturn_right;
 300   1      //  pro_right = (*current_time_config).rturn_right;
 301   1      //  
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 17:51:44 PAGE 6   

 302   1        if((runtime>tune_time)&&(current_time_config_index!=mode_low)){
 303   2          load_time_config(mode_low);
 304   2          tune_time = runtime + ADJUST_TIME_SHORT;
 305   2        }else{
 306   2          pro_left  = (*current_time_config).lturn_right;
 307   2          pro_right = (*current_time_config).rturn_right;
 308   2        }
 309   1      }
 310          
 311          void turn_left_max() // 大幅度左修正
 312          {
 313   1        
 314   1        if(runtime>tune_time){
 315   2          if(current_time_config_index!=mode_low){
 316   3            slight_stop();
 317   3            load_time_config(mode_low);
 318   3            tune_time = runtime + ADJUST_TIME_LONG;
 319   3          }
 320   2        }else{
 321   2          pro_left  = (*current_time_config).lturn_left_max;
 322   2          pro_right = (*current_time_config).rturn_left_max;
 323   2        }
 324   1      }
 325          
 326          void turn_right_max() // 大幅度右修正
 327          {
 328   1        if(runtime>tune_time){
 329   2          if(current_time_config_index!=mode_low){
 330   3            slight_stop();
 331   3            load_time_config(mode_low);
 332   3            tune_time = runtime + ADJUST_TIME_LONG;
 333   3          }
 334   2        }else{
 335   2          pro_left  = (*current_time_config).lturn_right_max;
 336   2          pro_right = (*current_time_config).rturn_right_max;
 337   2        }
 338   1      }
 339          
 340          //左转90度
 341          void turn_left_90() 
 342          {
 343   1        
 344   1        unsigned int i=(*current_time_config).ltime;         //转过度减少时间，没转够增加时间
 345   1        load_time_config(mode_low);
 346   1          tune_time = runtime + ADJUST_TIME_LONG;
 347   1        while(i--)
 348   1        {
 349   2          // 右电机正转，  左电机反转
 350   2          //if(i%2) 
 351   2          IN2_1 = 1,IN1_2 =1;   //降低转弯速度,便于控制
 352   2          //else IN2_1 = 0,IN1_2 =0;
 353   2        }
 354   1        IN2_1 = 0;
 355   1        IN1_2 = 0;
 356   1      }
 357          
 358          // 左转弯实现
 359          // 左电机正转，右电机反转 加快转弯速度
 360          void turn_right_90() //右转90度
 361          {
 362   1        
 363   1        unsigned int i=(*current_time_config).rtime;         //转过度减少时间，没转够增加时间
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 17:51:44 PAGE 7   

 364   1        load_time_config(mode_low);
 365   1          
 366   1          tune_time = runtime + ADJUST_TIME_SHORT;
 367   1        while(i--)
 368   1        {
 369   2          //if(i%2) 
 370   2          IN1_1 = 1,IN2_2 =1;   //降低转弯速度,便于控制
 371   2          //else IN1_1 = 0,IN2_2 =0;
 372   2        }
 373   1        IN1_1 = 0;
 374   1        IN2_2 = 0;
 375   1      }
 376          
 377          void go_straight()
 378          {
 379   1        unsigned int i=5000;
 380   1        while(i--)
 381   1        {
 382   2          if(i%4) IN1_1 = 1,IN2_1 =1;   //降低速度,便于控制
 383   2          else IN1_1 = 0,IN2_1 =0;
 384   2        }
 385   1        IN1_1 = 0;
 386   1        IN2_1 = 0;
 387   1      }
 388          
 389          void stop()
 390          {
 391   1        unsigned int i,j=0;
 392   1        // 防止中断函数导致停止失败
 393   1        for(i=5;i>1;i--) wait();
 394   1        while(1){
 395   2          key_control();
 396   2          set_display(j++);
 397   2          for(i=500;i>1;i--){
 398   3            delay(10);
 399   3            BUZZER = !BUZZER;
 400   3          } 
 401   2        }
 402   1      }
 403          
 404          void slight_stop(){
 405   1        unsigned int i = 200;         //转过度减少时间，没转够增加时间
 406   1        while(i--)
 407   1        {
 408   2          // 右电机正转，  左电机反转
 409   2          if(i%4) IN2_2 = 1,IN1_2 =1;   //降低转弯速度,便于控制
 410   2          else IN1_1 = 0,IN1_2 =0;
 411   2        }
 412   1        IN2_1 = 0;
 413   1        IN2_2 = 0;
 414   1      }
 415          
 416          /**
 417           *    十字路口处理程序
 418           *    1、停止当前调整动作
 419           *    2、测距
 420           *    3、判断应该【到终点、左90°转、右90转、直行】
 421           *    4、结束后恢复定时器
 422           */
 423          void crossroad()
 424          {
 425   1        if(XUNJI_1 && XUNJI_2 && XUNJI_3 && XUNJI_4)  //依旧四灯全灭,有理由相信遇到十字路口
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 17:51:44 PAGE 8   

 426   1        {
 427   2          wait();
 428   2          if(current_turn_config<sizeof(turn_configs)){
 429   3            if(turn_configs[current_turn_config]==LEFT){
 430   4              turn_left_90();
 431   4              go_straight();
 432   4              TR0 = 1;   //开启T0中断
 433   4              TR1 = 1;   //开启T1中断
 434   4            }else if(turn_configs[current_turn_config]==RIGHT){
 435   4              turn_right_90();
 436   4              go_straight();
 437   4              TR0 = 1;   //开启T0中断
 438   4              TR1 = 1;   //开启T1中断
 439   4            }else if(turn_configs[current_turn_config]==STRAIGHT){
 440   4              // 快速直行走出十字路口区域
 441   4              go_straight();
 442   4              TR0 = 1;   //开启T0中断
 443   4              TR1 = 1;   //开启T1中断
 444   4            }
 445   3          }else{
 446   3            stop();
 447   3            current_turn_config = 0;
 448   3          }
 449   2          current_turn_config++;
 450   2          set_display(current_turn_config);
 451   2        }
 452   1      }
 453          
 454          void wait() //暂停
 455          {
 456   1        TR1 = 0;
 457   1        TR0 = 0;
 458   1        time = 0;
 459   1        tune_time = 0;
 460   1        runtime = 0;
 461   1        pro_left = 0;
 462   1        pro_right = 0;
 463   1        IN1_1 = IN1_2 = IN2_1 = IN2_2 = 0;
 464   1      }
 465          /**
 466           *    循迹1、2、3、4 对应 左、左中、右中、右
 467           *    地面为白色时，灯亮，端口电平->低
 468           *    地面为黑色时，灯灭，端口电平->高
 469           *    左边灯灭，
 470           */
 471          void infrared() //循迹
 472          {
 473   1        //四灯全灭,可能遇到十字路口
 474   1        if(XUNJI_1 && XUNJI_2 && XUNJI_3 && XUNJI_4)
 475   1          crossroad();
 476   1        //严重偏右
 477   1        else if(XUNJI_1)
 478   1          turn_left_max();
 479   1        //严重偏左
 480   1        else if(XUNJI_4)
 481   1          turn_right_max();
 482   1        //中间
 483   1        else if(XUNJI_2 && XUNJI_3)
 484   1          straight();
 485   1        //偏右 (注：在严重偏右后面，即不发生严重偏右)
 486   1        else if(XUNJI_2)
 487   1          turn_left();
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 17:51:44 PAGE 9   

 488   1        //偏左 (注：在严重偏左后面，即不发生严重偏左)
 489   1        else if(XUNJI_3)
 490   1          turn_right();
 491   1        else
 492   1          straight();
 493   1          
 494   1      }
 495          
 496          // PWM 输出
 497          //电机输出函数
 498          void output()
 499          {
 500   1        if(time > 39)
 501   1        {
 502   2          time = 0;
 503   2          // 直行
 504   2          IN1_1 =1; IN2_1 = 1;
 505   2          IN1_2 =0; IN2_2 = 0;
 506   2          // 计时器 20*100us = 2 ms
 507   2          // 清零防止 tune_time > runtime 导致模式不能切换 
 508   2          if(runtime++==0)tune_time=0;
 509   2        }
 510   1        
 511   1        if(time == pro_left)  IN1_1 = 0;
 512   1        if(time == pro_right) IN2_1 = 0;
 513   1      }
 514          
 515          void set_display(unsigned char digit){
 516   1        display = segdata [digit%10];
 517   1      }
 518          
 519          void set_display_now(){
 520   1        A=BX=C=D=E=F=G=0;
 521   1        A = display&0x01;
 522   1        BX = display&0x02;
 523   1        C = display&0x04;
 524   1        D = display&0x08;
 525   1        E = display&0x10;
 526   1        F = display&0x20;
 527   1        G = display&0x40;
 528   1      }
 529          
 530          // 读取预设参数，快速设置参数
 531          void load_time_config(char idx){
 532   1        current_time_config_index = idx;
 533   1        current_time_config = &speed_level_configs + current_time_config_index;
 534   1        set_display(current_time_config_index);
 535   1      }
 536          
 537          // 检测轮子状态
 538          void get_wheel_steps(){
 539   1        static unsigned int last_left = 1, last_right = 1;
 540   1        if(CESU_1 != last_left){left_steps++; last_left=CESU_1;} 
 541   1        if(CESU_2 != last_right){set_display(right_steps++); last_right=CESU_2;} 
 542   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1341    ----
   CONSTANT SIZE    =    220    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 17:51:44 PAGE 10  

   DATA SIZE        =     29       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
