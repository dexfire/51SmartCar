C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 14:47:58 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE XUNJI
OBJECT MODULE PLACED IN .\Objects\xunji.obj
COMPILER INVOKED BY: D:\Software\Keil_v5\C51\BIN\C51.EXE xunji.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\xunji.lst) TABS(2) OBJECT(.\Objects\xunji.obj)

line level    source

   1          #include <REG52.h>
   2          //#include "oled.h"
   3          //#include "bmp.h"
   4          #include "xunji.h"
   5          //#include "eeprom.h"
   6          
   7          unsigned char time = 0;
   8          unsigned char pro_left=0,pro_right=0;
   9          struct time_config *current_time_config;
  10          unsigned char code segdata[]= {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f/*,0x77,0x7c,0x39,0x5e,0x7
             -9,0x71*/};
  11          unsigned char display;
  12          code struct time_config speed_level_configs[] = {
  13            
  14            /* 单独一个轮子拐弯可能拖不动 */
  15            
  16            
  17            // Mode 1
  18            // 完全跟线走，稍慢, 表现良好
  19            // 6T 模式下动不了 
  20            { 65536 - 200,  6,6,  4,6,3,6,  6,4,6,3,  12500,12000 },
  21          
  22            // Mode 2
  23            // 完全根线，小弯大弯表现良好，修复能力强，表现优秀
  24            { 65536 - 200,  6,6,  3,6,2,6, 6,3,6,2,12500,12000 },
  25          
  26            // Mode 3
  27            // 大弯修复能力弱，走着走着就偏了
  28            //{6,6,  1,5,0,5, 5,1,5,0,12000,12000 },
  29            // 尝试减小偏转力度
  30            { 65536 - 200,6,6,  1,4,0,4, 4,1,4,0,12000,12000 },
  31          
  32            // Mode 4
  33            // 6T 模式下工作良好，表现很好   12T 也还可以
  34            { 65536 - 200,9,9,  3,5,0,5, 5,3,5,0,12000,12000 },
  35          
  36            // Mode 5
  37            // 高速，拐弯溢出边界
  38            //{15,15,  2,7,1,7, 7,2,7,1,12000,12000 },
  39            // 尝试再次降低修正幅度   效果还可以   稳定性差
  40            { 65536 - 300,13,13,  5,7,3,7, 7,5,7,3,12000,12000 },
  41          };
  42          
  43          code struct schdule_config schdule_configs[] = {
  44            {1,2},
  45            {1,3},
  46            {1,4},
  47            {0,2},
  48            {0,3},
  49            {0,4},
  50          };
  51          unsigned char turn_configs[] = {LEFT,RIGHT,STRAIGHT,RIGHT,LEFT};
  52          unsigned char current_time_config_index = 0;
  53          unsigned char current_schdule_config = 0;
C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 14:47:58 PAGE 2   

  54          unsigned char current_turn_config = 0;
  55          unsigned char mode_low = 0;
  56          unsigned char mode_high = 0;
  57          unsigned int tune_time = 0;
  58          unsigned int runtime = 0;
  59          unsigned int left_steps=0,right_steps=0;
  60          
  61          void delay(int i)      //12M   i=500,t=500ms
  62          {
  63   1        unsigned char j;
  64   1        for( ;i>0;i--)
  65   1          for(j=220;j>0;j--);
  66   1      }
  67          
  68          char key_scan(void)    //按键扫描
  69          {
  70   1        C0=0;
  71   1        delay(1);
  72   1        if(!(R0&&R1&&R2)){BUZZER=0;delay(10);} 
  73   1        if(!(R0&&R1&&R2))
  74   1        {
  75   2          if(!R0) {while(!R0);BUZZER=1;return 1;}
  76   2          if(!R1) {while(!R1);BUZZER=1;return 2;}
  77   2          if(!R2) {while(!R2);BUZZER=1;return 3;}
  78   2        }
  79   1        C0=1;
  80   1        
  81   1        C1=0;
  82   1        delay(1);
  83   1        if(!(R0&&R1&&R2)) delay(10);
  84   1        if(!(R0&&R1&&R2))
  85   1        {
  86   2          if(!R0) {while(!R0);BUZZER=1;return 4;}
  87   2          if(!R1) {while(!R1);BUZZER=1;return 5;}
  88   2          if(!R2) {while(!R2);BUZZER=1;return 6;}
  89   2        }
  90   1        C1=1;
  91   1        
  92   1        C2=0;
  93   1        delay(1);
  94   1        if(!(R0&&R1&&R2)) delay(10);
  95   1        if(!(R0&&R1&&R2))
  96   1        {
  97   2          if(!R0) {while(!R0);BUZZER=1;return 7;}
  98   2          if(!R1) {while(!R1);BUZZER=1;return 8;}
  99   2          if(!R2) {while(!R2);BUZZER=1;return 9;}
 100   2        }
 101   1        C2=1;
 102   1        
 103   1        return 0;
 104   1      }
 105          
 106          void key_control()
 107          {
 108   1        switch(key_scan()) 
 109   1          {
 110   2            case 1:
 111   2              set_display(current_time_config_index);
 112   2              break;
 113   2      
 114   2            case 2:
 115   2              set_display(current_turn_config);
C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 14:47:58 PAGE 3   

 116   2              break;
 117   2            
 118   2            case 3:
 119   2              set_display(tune_time);
 120   2              break;
 121   2      
 122   2            case 8:        //换模式
 123   2            {
 124   3              // // 循环切换速度
 125   3              // current_time_config_index++;
 126   3              // if(current_time_config_index>=sizeof(speed_level_configs)/sizeof(struct time_config))
 127   3              //  current_time_config_index = 0;
 128   3              // load_time_config(current_time_config_index);
 129   3              current_schdule_config++;
 130   3              if(current_schdule_config>=sizeof(schdule_configs)/sizeof(struct schdule_config)){
 131   4                current_schdule_config = 0;
 132   4              }
 133   3              set_display(current_schdule_config);
 134   3              mode_low = schdule_configs[current_schdule_config].adjust_time_config;
 135   3              mode_high = schdule_configs[current_schdule_config].straight_time_config;
 136   3              break;
 137   3              // page--;
 138   3              // if(page<1) page=1;
 139   3              // set_display(page);
 140   3              // break;
 141   3            }
 142   2            // 开始、暂停、继续
 143   2            case 9:
 144   2            {
 145   3              TR0 = !TR0; 
 146   3              TR1 = TR0; 
 147   3              set_display(TR0*(current_time_config_index+1));
 148   3              IN1_1 = 0;
 149   3              IN1_2 = 0;
 150   3              IN2_1 = 0;
 151   3              IN2_2 = 0;
 152   3              tune_time = 0;
 153   3              runtime = 0;
 154   3              break;
 155   3            }
 156   2          }
 157   1      }
 158          
 159          
 160          void init()
 161          {
 162   1        EA=1;
 163   1        TMOD=0x12;      //配置为定时器0 8位重装模式，定时器1为16位定时器
 164   1        
 165   1        TH0=256-TIMER0;                 //12M，定时50us
 166   1        TL0=256-TIMER0;
 167   1        ET0=1;
 168   1        TR0=0;
 169   1      
 170   1        TH1=(65536-1000)>>8;                 //12M，定时2ms
 171   1        TL1=65536-1000;
 172   1        ET1=1;
 173   1        TR1=0;
 174   1        
 175   1        // T2CON = 0;  //0000 0000   ;定时器2配置为16位自动重装定时器
 176   1        // RCAP2H = _iror_(65536-250,8);
 177   1        // RCAP2L = 65536-250;
C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 14:47:58 PAGE 4   

 178   1        // TH2 = _iror_(65536-250,8);
 179   1        // TL2 = 65536-250;
 180   1        // ET2 = 1;
 181   1        // TR2 = 0;
 182   1        
 183   1        TRIG = 0;
 184   1        ECHO = 1;
 185   1        SIG1 = 0;
 186   1        BUZZER = 1;
 187   1        IN1_1 = 0;
 188   1        IN1_2 = 0;
 189   1        IN2_1 = 0;
 190   1        IN2_2 = 0;
 191   1        //eeprom_init();
 192   1        //set_display(eeprom_read_byte(0));
 193   1      }
 194          
 195          void straight() //走直线
 196          {
 197   1        // 切换配置
 198   1        // 由于比较耗时，所以判断一下当前模式是值得的
 199   1        if((runtime>tune_time)&&(current_time_config_index!=mode_high)){
 200   2          load_time_config(mode_high);
 201   2        }else{
 202   2          pro_left  = (*current_time_config).lstraight;
 203   2          pro_right = (*current_time_config).rstraight;
 204   2        }
 205   1      }
 206          
 207          void turn_left() //左修正
 208          {
 209   1      
 210   1        pro_left  = (*current_time_config).lturn_left;
 211   1        pro_right = (*current_time_config).rturn_left;
 212   1        
 213   1      //  if((runtime>tune_time)&&(current_time_config_index!=mode_low)){
 214   1      //    load_time_config(mode_low);
 215   1      //    
 216   1      //    tune_time = runtime + ADJUST_TIME_SHORT;
 217   1      //  }else{
 218   1      //    pro_left  = (*current_time_config).lturn_left;
 219   1      //    pro_right = (*current_time_config).rturn_left;
 220   1      //  }
 221   1      }
 222          
 223          void turn_right() //右修正
 224          {
 225   1        pro_left  = (*current_time_config).lturn_right;
 226   1        pro_right = (*current_time_config).rturn_right;
 227   1        
 228   1      //  if((runtime>tune_time)&&(current_time_config_index!=mode_low)){
 229   1      //    load_time_config(mode_low);
 230   1      //    tune_time = runtime + ADJUST_TIME_SHORT;
 231   1      //  }else{
 232   1      //    pro_left  = (*current_time_config).lturn_right;
 233   1      //    pro_right = (*current_time_config).rturn_right;
 234   1      //  }
 235   1      }
 236          
 237          void turn_left_max() // 大幅度左修正
 238          {
 239   1        
C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 14:47:58 PAGE 5   

 240   1        if((runtime>tune_time)&&(current_time_config_index!=mode_low)){
 241   2          load_time_config(mode_low);
 242   2          tune_time = runtime + ADJUST_TIME_LONG;
 243   2        }else{
 244   2          pro_left  = (*current_time_config).lturn_left_max;
 245   2          pro_right = (*current_time_config).rturn_left_max;
 246   2        }
 247   1      }
 248          
 249          void turn_right_max() // 大幅度右修正
 250          {
 251   1        if((runtime>tune_time)&&(current_time_config_index!=mode_low)){
 252   2          load_time_config(mode_low);
 253   2          tune_time = runtime + ADJUST_TIME_LONG;
 254   2        }else{
 255   2          pro_left  = (*current_time_config).lturn_right_max;
 256   2          pro_right = (*current_time_config).rturn_right_max;
 257   2        }
 258   1      }
 259          
 260          //左转90度
 261          void turn_left_90() 
 262          {
 263   1        unsigned int i=(*current_time_config).ltime;         //转过度减少时间，没转够增加时间
 264   1        while(i--)
 265   1        {
 266   2          // 右电机正转，  左电机反转
 267   2          if(i%4) IN2_1 = 1,IN1_2 =1;   //降低转弯速度,便于控制
 268   2          else IN2_1 = 0,IN1_2 =0;
 269   2        }
 270   1        IN2_1 = 0;
 271   1        IN1_2 = 0;
 272   1      }
 273          
 274          // 左转弯实现
 275          // 左电机正转，右电机反转 加快转弯速度
 276          void turn_right_90() //右转90度
 277          {
 278   1        unsigned int i=(*current_time_config).rtime;         //转过度减少时间，没转够增加时间
 279   1        while(i--)
 280   1        {
 281   2          if(i%4) IN1_1 = 1,IN2_2 =1;   //降低转弯速度,便于控制
 282   2          else IN1_1 = 0,IN2_2 =0;
 283   2        }
 284   1        IN1_1 = 0;
 285   1        IN2_2 = 0;
 286   1      }
 287          
 288          void go_straight()
 289          {
 290   1        unsigned int i=5000;
 291   1        while(i--)
 292   1        {
 293   2          if(i%4) IN1_1 = 1,IN2_1 =1;   //降低速度,便于控制
 294   2          else IN1_1 = 0,IN2_1 =0;
 295   2        }
 296   1        IN1_1 = 0;
 297   1        IN2_1 = 0;
 298   1      }
 299          
 300          void stop()
 301          {
C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 14:47:58 PAGE 6   

 302   1        unsigned int i,j=0;
 303   1        // 防止中断函数导致停止失败
 304   1        for(i=5;i>1;i--) wait();
 305   1        while(1){
 306   2          key_control();
 307   2          set_display(j++);
 308   2          for(i=500;i>1;i--){
 309   3            delay(10);
 310   3            BUZZER = !BUZZER;
 311   3          } 
 312   2        }
 313   1      }
 314          
 315          /**
 316           *    十字路口处理程序
 317           *    1、停止当前调整动作
 318           *    2、测距
 319           *    3、判断应该【到终点、左90°转、右90转、直行】
 320           *    4、结束后恢复定时器
 321           */
 322          void crossroad()
 323          {
 324   1        if(XUNJI_1 && XUNJI_2 && XUNJI_3 && XUNJI_4)  //依旧四灯全灭,有理由相信遇到十字路口
 325   1        {
 326   2          wait();
 327   2          if(current_turn_config<sizeof(turn_configs)){
 328   3            if(turn_configs[current_turn_config]==LEFT){
 329   4              turn_left_90();
 330   4              go_straight();
 331   4              TR0 = 1;   //开启T0中断
 332   4              TR1 = 1;   //开启T1中断
 333   4            }else if(turn_configs[current_turn_config]==RIGHT){
 334   4              turn_right_90();
 335   4              go_straight();
 336   4              TR0 = 1;   //开启T0中断
 337   4              TR1 = 1;   //开启T1中断
 338   4            }else{
 339   4              // 快速直行走出十字路口区域
 340   4              go_straight();
 341   4              TR0 = 1;   //开启T0中断
 342   4              TR1 = 1;   //开启T1中断
 343   4            }
 344   3      
 345   3          }else{
 346   3            stop();
 347   3            current_turn_config = 0;
 348   3          }
 349   2          current_turn_config++;
 350   2          set_display(current_turn_config);
 351   2        }
 352   1      }
 353          
 354          void wait() //暂停
 355          {
 356   1        TR1 = 0;
 357   1        TR0 = 0;
 358   1        time = 0;
 359   1        tune_time = 0;
 360   1        runtime = 0;
 361   1        pro_left = 0;
 362   1        pro_right = 0;
 363   1        IN1_1 = 0;
C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 14:47:58 PAGE 7   

 364   1        IN1_2 = 0;
 365   1        IN2_1 = 0;
 366   1        IN2_2 = 0;
 367   1      }
 368          /**
 369           *    循迹1、2、3、4 对应 左、左中、右中、右
 370           *    地面为白色时，灯亮，端口电平->低
 371           *    地面为黑色时，灯灭，端口电平->高
 372           *    左边灯灭，
 373           */
 374          void infrared() //循迹
 375          {
 376   1        //四灯全灭,可能遇到十字路口
 377   1        if(XUNJI_1 && XUNJI_2 && XUNJI_3 && XUNJI_4)
 378   1          crossroad();
 379   1        //严重偏右
 380   1        else if(XUNJI_1)
 381   1          turn_left_max();
 382   1        //严重偏左
 383   1        else if(XUNJI_4)
 384   1          turn_right_max();
 385   1        //中间
 386   1        else if(XUNJI_2 && XUNJI_3)
 387   1          straight();
 388   1        //偏右 (注：在严重偏右后面，即不发生严重偏右)
 389   1        else if(XUNJI_2)
 390   1          turn_left();
 391   1        //偏左 (注：在严重偏左后面，即不发生严重偏左)
 392   1        else if(XUNJI_3)
 393   1          turn_right();
 394   1        else
 395   1          straight();
 396   1          
 397   1      }
 398          
 399          // PWM 输出
 400          void output()    //电机输出函数
 401          {
 402   1        if(time >= 20)
 403   1        {
 404   2          time = 0;
 405   2          IN1_1 = 1;    //左电机正转
 406   2          IN1_2 = 0;
 407   2          IN2_1 = 1;    //右电机正转
 408   2          IN2_2 = 0;
 409   2          // 计时器 20*100us = 2 ms
 410   2          if(runtime++==0)tune_time=0;
 411   2        }
 412   1        
 413   1        if(time >= pro_left)    IN1_1 = 0;
 414   1        if(time >= pro_right)   IN2_1 = 0;
 415   1        
 416   1      }
 417          
 418          void set_display(unsigned char digit){
 419   1        display = segdata [digit%10];
 420   1      }
 421          
 422          void set_display_now(){
 423   1        A=BX=C=D=E=F=G=0;
 424   1        A = display&0x01;
 425   1        BX = display&0x02;
C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 14:47:58 PAGE 8   

 426   1        C = display&0x04;
 427   1        D = display&0x08;
 428   1        E = display&0x10;
 429   1        F = display&0x20;
 430   1        G = display&0x40;
 431   1      }
 432          
 433          // 读取预设参数，快速设置参数
 434          void load_time_config(char idx){
 435   1        current_time_config_index = idx;
 436   1        current_time_config = speed_level_configs + current_time_config_index;
 437   1        set_display(current_time_config_index+1);
 438   1      }
 439          
 440          
 441          // 检测轮子状态
 442          void get_wheel_steps(){
 443   1        static unsigned int last_left = 1, last_right = 1;
 444   1        if(CESU_1 != last_left){left_steps++; last_left=CESU_1;} 
 445   1        if(CESU_2 != last_right){set_display(right_steps++); last_right=CESU_2;} 
 446   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1167    ----
   CONSTANT SIZE    =    102    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     29       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
