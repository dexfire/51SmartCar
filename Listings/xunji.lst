C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 12:48:58 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE XUNJI
OBJECT MODULE PLACED IN .\Objects\xunji.obj
COMPILER INVOKED BY: D:\Software\Keil_v5\C51\BIN\C51.EXE xunji.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\xunji.lst) TABS(2) OBJECT(.\Objects\xunji.obj)

line level    source

   1          #include <REG52.h>
   2          #include <intrins.h>
   3          //#include "oled.h"
   4          //#include "bmp.h"
   5          #include "xunji.h"
   6          //#include "eeprom.h"
   7          
   8          unsigned char time = 0;
   9          unsigned char pro_left=0,pro_right=0;
  10          struct time_config *current_time_config;
  11          unsigned char code segdata[]= {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f/*,0x77,0x7c,0x39,0x5e,0x7
             -9,0x71*/};
  12          unsigned char display;
  13          code struct time_config speed_level_configs[] = {
  14            
  15            /* 单独一个轮子拐弯可能拖不动 */
  16            
  17            
  18            // Mode 1
  19            // 完全跟线走，稍慢, 表现良好
  20            // 6T 模式下动不了 
  21            { 200,  5,5,  1,5,0,5,  5,1,5,0,  12500,12000 },
  22          
  23            // Mode 2
  24            // 完全根线，小弯大弯表现良好，修复能力强，表现优秀
  25            { 200,  6,6,  3,6,2,6, 6,3,6,2,12500,12000 },
  26          
  27            // Mode 3
  28            // 大弯修复能力弱，走着走着就偏了
  29            //{6,6,  1,5,0,5, 5,1,5,0,12000,12000 },
  30            // 尝试减小偏转力度
  31            {200,6,6,  1,4,0,4, 4,1,4,0,12000,12000 },
  32          
  33            // Mode 4
  34            // 6T 模式下工作良好，表现很好   12T 也还可以
  35            {200,9,9,  3,5,0,5, 5,3,5,0,12000,12000 },
  36          
  37            // Mode 5
  38            // 高速，拐弯溢出边界
  39            //{15,15,  2,7,1,7, 7,2,7,1,12000,12000 },
  40            // 尝试再次降低修正幅度   效果还可以   稳定性差
  41            {300,13,13,  5,7,3,7, 7,5,7,3,12000,12000 },
  42          };
  43          
  44          code struct schdule_config schdule_configs[] = {
  45            {0,2},
  46            {0,3},
  47            {1,2},
  48            {1,3},
  49            {0,4},
  50            {1,4},
  51          };
  52          unsigned char turn_configs[] = {LEFT,RIGHT,STRAIGHT,RIGHT,LEFT};
  53          unsigned char current_time_config_index = 0;
C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 12:48:58 PAGE 2   

  54          unsigned char current_schdule_config = 0;
  55          unsigned char current_turn_config = 0;
  56          unsigned char mode_low = 0;
  57          unsigned char mode_high = 0;
  58          unsigned int tune_time = 0;
  59          unsigned int runtime = 0;
  60          unsigned int left_steps=0,right_steps=0;
  61          
  62          void delay(int i)      //12M   i=500,t=500ms
  63          {
  64   1        unsigned char j;
  65   1        for( ;i>0;i--)
  66   1          for(j=220;j>0;j--);
  67   1      }
  68          
  69          char key_scan(void)    //按键扫描
  70          {
  71   1        C0=0;
  72   1        delay(1);
  73   1        if(!(R0&&R1&&R2)){BUZZER=0;delay(10);} 
  74   1        if(!(R0&&R1&&R2))
  75   1        {
  76   2          if(!R0) {while(!R0);BUZZER=1;return 1;}
  77   2          if(!R1) {while(!R1);BUZZER=1;return 2;}
  78   2          if(!R2) {while(!R2);BUZZER=1;return 3;}
  79   2        }
  80   1        C0=1;
  81   1        
  82   1        C1=0;
  83   1        delay(1);
  84   1        if(!(R0&&R1&&R2)) delay(10);
  85   1        if(!(R0&&R1&&R2))
  86   1        {
  87   2          if(!R0) {while(!R0);BUZZER=1;return 4;}
  88   2          if(!R1) {while(!R1);BUZZER=1;return 5;}
  89   2          if(!R2) {while(!R2);BUZZER=1;return 6;}
  90   2        }
  91   1        C1=1;
  92   1        
  93   1        C2=0;
  94   1        delay(1);
  95   1        if(!(R0&&R1&&R2)) delay(10);
  96   1        if(!(R0&&R1&&R2))
  97   1        {
  98   2          if(!R0) {while(!R0);BUZZER=1;return 7;}
  99   2          if(!R1) {while(!R1);BUZZER=1;return 8;}
 100   2          if(!R2) {while(!R2);BUZZER=1;return 9;}
 101   2        }
 102   1        C2=1;
 103   1        
 104   1        return 0;
 105   1      }
 106          
 107          void key_control()
 108          {
 109   1        switch(key_scan()) 
 110   1          {
 111   2            case 1:
 112   2              set_display(current_time_config_index);
 113   2              break;
 114   2      
 115   2            case 2:
C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 12:48:58 PAGE 3   

 116   2              set_display(current_turn_config);
 117   2              break;
 118   2            
 119   2            case 3:
 120   2              set_display(tune_time);
 121   2              break;
 122   2      
 123   2            case 8:        //换模式
 124   2            {
 125   3              // // 循环切换速度
 126   3              // current_time_config_index++;
 127   3              // if(current_time_config_index>=sizeof(speed_level_configs)/sizeof(struct time_config))
 128   3              //  current_time_config_index = 0;
 129   3              // load_time_config(current_time_config_index);
 130   3              current_schdule_config++;
 131   3              if(current_schdule_config>=sizeof(schdule_configs)/sizeof(struct schdule_config)){
 132   4                current_schdule_config = 0;
 133   4              }
 134   3              set_display(current_schdule_config);
 135   3              mode_low = schdule_configs[current_schdule_config].adjust_time_config;
 136   3              mode_high = schdule_configs[current_schdule_config].straight_time_config;
 137   3              break;
 138   3              // page--;
 139   3              // if(page<1) page=1;
 140   3              // set_display(page);
 141   3              // break;
 142   3            }
 143   2            // 开始、暂停、继续
 144   2            case 9:
 145   2            {
 146   3              TR0 = !TR0; 
 147   3              TR1 = TR0; 
 148   3              set_display(TR0*(current_time_config_index+1));
 149   3              IN1_1 = 0;
 150   3              IN1_2 = 0;
 151   3              IN2_1 = 0;
 152   3              IN2_2 = 0;
 153   3              tune_time = 0;
 154   3              runtime = 0;
 155   3              break;
 156   3            }
 157   2          }
 158   1      }
 159          
 160          
 161          void init()
 162          {
 163   1        EA=1;
 164   1        TMOD=0x12;      //配置为定时器0 8位重装模式，定时器1为16位定时器
 165   1        
 166   1        TH0=256-TIMER0;                 //12M，定时50us
 167   1        TL0=256-TIMER0;
 168   1        ET0=1;
 169   1        TR0=0;
 170   1      
 171   1        TH1=_iror_(65536-1000,8);                 //12M，定时2ms
 172   1        TL1=65536-1000;
 173   1        ET1=1;
 174   1        TR1=0;
 175   1        
 176   1        // T2CON = 0;  //0000 0000   ;定时器2配置为16位自动重装定时器
 177   1        // RCAP2H = _iror_(65536-250,8);
C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 12:48:58 PAGE 4   

 178   1        // RCAP2L = 65536-250;
 179   1        // TH2 = _iror_(65536-250,8);
 180   1        // TL2 = 65536-250;
 181   1        // ET2 = 1;
 182   1        // TR2 = 0;
 183   1        
 184   1        TRIG = 0;
 185   1        ECHO = 1;
 186   1        SIG1 = 0;
 187   1        BUZZER = 1;
 188   1        IN1_1 = 0;
 189   1        IN1_2 = 0;
 190   1        IN2_1 = 0;
 191   1        IN2_2 = 0;
 192   1        //eeprom_init();
 193   1        //set_display(eeprom_read_byte(0));
 194   1      }
 195          
 196          void straight() //走直线
 197          {
 198   1        // 切换配置
 199   1        // 由于比较耗时，所以判断一下当前模式是值得的
 200   1        if((runtime>tune_time)&&(current_time_config_index!=mode_high)){
 201   2          load_time_config(mode_high);
 202   2        }else{
 203   2          pro_left  = (*current_time_config).lstraight;
 204   2          pro_right = (*current_time_config).rstraight;
 205   2        }
 206   1      }
 207          
 208          void turn_left() //左修正
 209          {
 210   1      
 211   1        pro_left  = (*current_time_config).lturn_left;
 212   1        pro_right = (*current_time_config).rturn_left;
 213   1        
 214   1      //  if((runtime>tune_time)&&(current_time_config_index!=mode_low)){
 215   1      //    load_time_config(mode_low);
 216   1      //    
 217   1      //    tune_time = runtime + ADJUST_TIME_SHORT;
 218   1      //  }else{
 219   1      //    pro_left  = (*current_time_config).lturn_left;
 220   1      //    pro_right = (*current_time_config).rturn_left;
 221   1      //  }
 222   1      }
 223          
 224          void turn_right() //右修正
 225          {
 226   1        pro_left  = (*current_time_config).lturn_right;
 227   1        pro_right = (*current_time_config).rturn_right;
 228   1        
 229   1      //  if((runtime>tune_time)&&(current_time_config_index!=mode_low)){
 230   1      //    load_time_config(mode_low);
 231   1      //    tune_time = runtime + ADJUST_TIME_SHORT;
 232   1      //  }else{
 233   1      //    pro_left  = (*current_time_config).lturn_right;
 234   1      //    pro_right = (*current_time_config).rturn_right;
 235   1      //  }
 236   1      }
 237          
 238          void turn_left_max() // 大幅度左修正
 239          {
C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 12:48:58 PAGE 5   

 240   1        
 241   1        if((runtime>tune_time)&&(current_time_config_index!=mode_low)){
 242   2          load_time_config(mode_low);
 243   2          tune_time = runtime + ADJUST_TIME_LONG;
 244   2        }else{
 245   2          pro_left  = (*current_time_config).lturn_left_max;
 246   2          pro_right = (*current_time_config).rturn_left_max;
 247   2        }
 248   1      }
 249          
 250          void turn_right_max() // 大幅度右修正
 251          {
 252   1        if((runtime>tune_time)&&(current_time_config_index!=mode_low)){
 253   2          load_time_config(mode_low);
 254   2          tune_time = runtime + ADJUST_TIME_LONG;
 255   2        }else{
 256   2          pro_left  = (*current_time_config).lturn_right_max;
 257   2          pro_right = (*current_time_config).rturn_right_max;
 258   2        }
 259   1      }
 260          
 261          //左转90度
 262          void turn_left_90() 
 263          {
 264   1        unsigned int i=(*current_time_config).ltime;         //转过度减少时间，没转够增加时间
 265   1        while(i--)
 266   1        {
 267   2          // 右电机正转，  左电机反转
 268   2          if(i%4) IN2_1 = 1,IN1_2 =1;   //降低转弯速度,便于控制
 269   2          else IN2_1 = 0,IN1_2 =0;
 270   2        }
 271   1        IN2_1 = 0;
 272   1        IN1_2 = 0;
 273   1      }
 274          
 275          // 左转弯实现
 276          // 左电机正转，右电机反转 加快转弯速度
 277          void turn_right_90() //右转90度
 278          {
 279   1        unsigned int i=(*current_time_config).rtime;         //转过度减少时间，没转够增加时间
 280   1        while(i--)
 281   1        {
 282   2          if(i%4) IN1_1 = 1,IN2_2 =1;   //降低转弯速度,便于控制
 283   2          else IN1_1 = 0,IN2_2 =0;
 284   2        }
 285   1        IN1_1 = 0;
 286   1        IN2_2 = 0;
 287   1      }
 288          
 289          void go_straight()
 290          {
 291   1        unsigned int i=5000;
 292   1        while(i--)
 293   1        {
 294   2          if(i%4) IN1_1 = 1,IN2_1 =1;   //降低速度,便于控制
 295   2          else IN1_1 = 0,IN2_1 =0;
 296   2        }
 297   1        IN1_1 = 0;
 298   1        IN2_1 = 0;
 299   1      }
 300          
 301          void stop()
C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 12:48:58 PAGE 6   

 302          {
 303   1        unsigned int i,j=0;
 304   1        // 防止中断函数导致停止失败
 305   1        for(i=5;i>1;i--) wait();
 306   1        while(1){
 307   2          key_control();
 308   2          set_display(j++);
 309   2          for(i=500;i>1;i--){
 310   3            delay(10);
 311   3            BUZZER = !BUZZER;
 312   3          } 
 313   2        }
 314   1      }
 315          
 316          /**
 317           *    十字路口处理程序
 318           *    1、停止当前调整动作
 319           *    2、测距
 320           *    3、判断应该【到终点、左90°转、右90转、直行】
 321           *    4、结束后恢复定时器
 322           */
 323          void crossroad()
 324          {
 325   1        if(XUNJI_1 && XUNJI_2 && XUNJI_3 && XUNJI_4)  //依旧四灯全灭,有理由相信遇到十字路口
 326   1        {
 327   2          wait();
 328   2          if(current_turn_config<sizeof(turn_configs)){
 329   3            if(turn_configs[current_turn_config]==LEFT){
 330   4              turn_left_90();
 331   4              go_straight();
 332   4              TR0 = 1;   //开启T0中断
 333   4              TR1 = 1;   //开启T1中断
 334   4            }else if(turn_configs[current_turn_config]==RIGHT){
 335   4              turn_right_90();
 336   4              go_straight();
 337   4              TR0 = 1;   //开启T0中断
 338   4              TR1 = 1;   //开启T1中断
 339   4            }else{
 340   4              // 快速直行走出十字路口区域
 341   4              go_straight();
 342   4              TR0 = 1;   //开启T0中断
 343   4              TR1 = 1;   //开启T1中断
 344   4            }
 345   3      
 346   3          }else{
 347   3            stop();
 348   3            current_turn_config = 0;
 349   3          }
 350   2          current_turn_config++;
 351   2          set_display(current_turn_config);
 352   2      
 353   2          // wait();
 354   2          // /**************************测距，判断左转还是右转*/
 355   2          // n=0;
 356   2          // TR2=1;           //开启T2中断  
 357   2          // TH2=0;
 358   2          // TL2=0;
 359   2          // TRIG = 1;
 360   2          // while(TL2<20); // 等待>10us
 361   2          // TRIG = 0;
 362   2          // while(!ECHO && n<2);
 363   2          // TL2=0;
C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 12:48:58 PAGE 7   

 364   2          // TH2=0;
 365   2          // while(ECHO);
 366   2          // TR2=0;             //关闭T2中断
 367   2          // if(n>=2) distance=999;  //即没障碍
 368   2          // else distance = ((TL2+TH2*256) /1000) *17;  //cm
 369   2          // //OLED_ShowNum3(110,2,distance);
 370   2      
 371   2          // if(distance < 15)     //小于15cm,到达终点，停止蜂鸣器响
 372   2          //  stop(); 
 373   2          // else if(distance < 30)   //大于15小于30,左转
 374   2          //  turn_left_90();
 375   2          // else if(distance < 50)   //大于30小于50,右转
 376   2          //  turn_right_90();
 377   2          // else
 378   2          //  go_straight();
 379   2        }
 380   1      }
 381          
 382          void wait() //暂停
 383          {
 384   1        TR1 = 0;
 385   1        TR0 = 0;
 386   1        time = 0;
 387   1        tune_time = 0;
 388   1        runtime = 0;
 389   1        pro_left = 0;
 390   1        pro_right = 0;
 391   1        IN1_1 = 0;
 392   1        IN1_2 = 0;
 393   1        IN2_1 = 0;
 394   1        IN2_2 = 0;
 395   1      }
 396          /**
 397           *    循迹1、2、3、4 对应 左、左中、右中、右
 398           *    地面为白色时，灯亮，端口电平->低
 399           *    地面为黑色时，灯灭，端口电平->高
 400           *    左边灯灭，
 401           */
 402          void infrared() //循迹
 403          {
 404   1        //四灯全灭,可能遇到十字路口
 405   1        if(XUNJI_1 && XUNJI_2 && XUNJI_3 && XUNJI_4)
 406   1          crossroad();
 407   1        //严重偏右
 408   1        else if(XUNJI_1)
 409   1          turn_left_max();
 410   1        //严重偏左
 411   1        else if(XUNJI_4)
 412   1          turn_right_max();
 413   1        //中间
 414   1        else if(XUNJI_2 && XUNJI_3)
 415   1          straight();
 416   1        //偏右 (注：在严重偏右后面，即不发生严重偏右)
 417   1        else if(XUNJI_2)
 418   1          turn_left();
 419   1        //偏左 (注：在严重偏左后面，即不发生严重偏左)
 420   1        else if(XUNJI_3)
 421   1          turn_right();
 422   1        else
 423   1          straight();
 424   1          
 425   1      }
C51 COMPILER V9.57.0.0   XUNJI                                                             06/30/2018 12:48:58 PAGE 8   

 426          
 427          // PWM 输出
 428          void output()    //电机输出函数
 429          {
 430   1        if(time >= 20)
 431   1        {
 432   2          time = 0;
 433   2          IN1_1 = 1;    //左电机正转
 434   2          IN1_2 = 0;
 435   2          IN2_1 = 1;    //右电机正转
 436   2          IN2_2 = 0;
 437   2          // 计时器 20*100us = 2 ms
 438   2          if(runtime++==0)tune_time=0;
 439   2        }
 440   1        
 441   1        if(time >= pro_left)    IN1_1 = 0;
 442   1        if(time >= pro_right)   IN2_1 = 0;
 443   1        
 444   1      }
 445          
 446          void set_display(unsigned char digit){
 447   1        display = segdata [digit%10];
 448   1      }
 449          
 450          void set_display_now(){
 451   1        A=BX=C=D=E=F=G=0;
 452   1        A = display&0x01;
 453   1        BX = display&0x02;
 454   1        C = display&0x04;
 455   1        D = display&0x08;
 456   1        E = display&0x10;
 457   1        F = display&0x20;
 458   1        G = display&0x40;
 459   1      }
 460          
 461          // 读取预设参数，快速设置参数
 462          void load_time_config(char idx){
 463   1        current_time_config_index = idx;
 464   1        current_time_config = speed_level_configs + current_time_config_index;
 465   1        set_display(current_time_config_index+1);
 466   1      }
 467          
 468          
 469          // 检测轮子状态
 470          void get_wheel_steps(){
 471   1        static unsigned int last_left = 1, last_right = 1;
 472   1        if(CESU_1 != last_left){left_steps++; last_left=CESU_1;} 
 473   1        if(CESU_2 != last_right){set_display(right_steps++); last_right=CESU_2;} 
 474   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1184    ----
   CONSTANT SIZE    =    102    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     29       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
