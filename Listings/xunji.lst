C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 12:47:24 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE XUNJI
OBJECT MODULE PLACED IN .\Objects\xunji.obj
COMPILER INVOKED BY: D:\Software\Keil_v5\C51\BIN\C51.EXE xunji.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\xunji.lst) TABS(2) OBJECT(.\Objects\xunji.obj)

line level    source

   1          #include <REG52.h>
   2          //#include "oled.h"
   3          //#include "bmp.h"
   4          #include "xunji.h"
   5          #include <stdio.h>
   6          //#include "eeprom.h"
   7          
   8          unsigned char time = 0;
   9          unsigned char pro_left=0,pro_right=0;
  10          struct time_config *current_time_config;
  11          unsigned char code segdata[]= {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f/*,0x77,0x7c,0x39,0x5e,0x7
             -9,0x71*/};
  12          unsigned char display;
  13          code struct time_config speed_level_configs[] = {
  14            
  15            // /* 单独一个轮子拐弯可能拖不动 */
  16          
  17            // // Mode 1
  18            // // 完全跟线走，稍慢, 表现良好
  19            // // 6T 模式下动不了 
  20            // { 65536 - 200, 5,5,  3,5,2,5,  5,3,5,2,  12500,12000 },
  21          
  22            // // Mode 2
  23            // // 完全根线，小弯大弯表现良好，修复能力强，表现优秀
  24            // { 65536 - 200, 6,6,  3,6,2,6, 6,3,6,2,12500,12000 },
  25          
  26            // // Mode 3
  27            // // 大弯修复能力弱，走着走着就偏了
  28            // //{6,6,  1,5,0,5, 5,1,5,0,12000,12000 },
  29            // // 尝试减小偏转力度
  30            // { 65536 - 200,6,6,  1,4,0,4, 4,1,4,0,12000,12000 },
  31          
  32            // // Mode 4
  33            // // 6T 模式下工作良好，表现很好   12T 也还可以
  34            // { 65536 - 200,9,9,  3,5,0,5, 5,3,5,0,12000,12000 },
  35          
  36            // // Mode 5
  37            // // 高速，拐弯溢出边界
  38            // //{15,15,  2,7,1,7, 7,2,7,1,12000,12000 },
  39            // // 尝试再次降低修正幅度   效果还可以   稳定性差
  40            // { 65536 - 200,13,13,  5,7,3,7, 7,5,7,3,12000,12000 },
  41          
  42              /* 单独一个轮子拐弯可能拖不动 */
  43          
  44            // 0
  45            // 完全跟线走，稍慢, 表现良好
  46            // 6T 模式下动不了 
  47            {4,4,  2,4,1,4, 4,2,4,1,  12000,12000 },
  48          
  49            // 1
  50            // 完全根线，小弯大弯表现良好，修复能力强，表现优秀
  51            {5,5,  1,5,0,5, 5,1,5,0  ,11000,12000 },
  52          
  53            // 2
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 12:47:24 PAGE 2   

  54            // 大弯修复能力弱，走着走着就偏了
  55            //{6,6,  1,5,0,5, 5,1,5,0,12000,12000 },
  56            // 尝试减小偏转力度
  57            {6,6,  1,5,0,5, 5,1,5,0,12000,12000 },
  58          
  59            // 3
  60            // 6T 模式下工作良好，表现很好   12T 也还可以
  61            {9,9,  0,4,0,5, 4,0,5,0, 12000,12000 },
  62          
  63            // 4
  64            // 尝试再次降低修正幅度   效果还可以   稳定性差
  65            {13,13,  4,7,2,7, 7,4,7,2,12000,12000 },
  66            
  67            // 5
  68            {6,6,  1,5,1,6, 5,1,6,1,  12000,12000 },
  69          
  70            // 6
  71            {7,6,  1,5,0,7, 5,1,7,0,  12000,12000 },
  72          
  73            // 7
  74            {9,9,  1,5,1,5, 5,1,6,1,  12000,12000 },
  75            
  76          };
  77          
  78          code struct schdule_config schdule_configs[] = {
  79            {1,1},  // 稳 慢
  80            {2,1},  // 很好
  81            {5,1},  // 好
  82            {6,1},  // 好 快
  83            {7,1},
  84          
  85            // 不稳定配置
  86          };
  87          
  88          unsigned char turn_configs[] = {
  89            // 比赛顺序
  90            //LEFT,RIGHT,STRAIGHT,RIGHT,LEFT
  91            RIGHT,
  92            LEFT,
  93            LEFT,
  94            RIGHT
  95          };
  96          
  97          unsigned char current_time_config_index = 0;
  98          unsigned char current_schdule_config = 0;
  99          unsigned char current_turn_config = 0;
 100          unsigned char mode_low = 1;
 101          unsigned char mode_high = 2;
 102          unsigned int tune_time = 0;
 103          unsigned int runtime = 0;
 104          unsigned int left_steps=0,right_steps=0;
 105          
 106          void delay(int i)      //12M   i=500,t=500ms
 107          {
 108   1        unsigned char j;
 109   1        for( ;i>0;i--)
 110   1          for(j=220;j>0;j--);
 111   1      }
 112          
 113          char key_scan(void)    //按键扫描
 114          {
 115   1        C0=0;
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 12:47:24 PAGE 3   

 116   1        delay(1);
 117   1        if(!(R0&&R1&&R2)){BUZZER=0;delay(10);} 
 118   1        if(!(R0&&R1&&R2))
 119   1        {
 120   2          if(!R0) {while(!R0);BUZZER=1;return 1;}
 121   2          if(!R1) {while(!R1);BUZZER=1;return 2;}
 122   2          if(!R2) {while(!R2);BUZZER=1;return 3;}
 123   2        }
 124   1        C0=1;
 125   1        
 126   1        C1=0;
 127   1        delay(1);
 128   1        if(!(R0&&R1&&R2)) delay(10);
 129   1        if(!(R0&&R1&&R2))
 130   1        {
 131   2          if(!R0) {while(!R0);BUZZER=1;return 4;}
 132   2          if(!R1) {while(!R1);BUZZER=1;return 5;}
 133   2          if(!R2) {while(!R2);BUZZER=1;return 6;}
 134   2        }
 135   1        C1=1;
 136   1        
 137   1        C2=0;
 138   1        delay(1);
 139   1        if(!(R0&&R1&&R2)) delay(10);
 140   1        if(!(R0&&R1&&R2))
 141   1        {
 142   2          if(!R0) {while(!R0);BUZZER=1;return 7;}
 143   2          if(!R1) {while(!R1);BUZZER=1;return 8;}
 144   2          if(!R2) {while(!R2);BUZZER=1;return 9;}
 145   2        }
 146   1        C2=1;
 147   1        
 148   1        return 0;
 149   1      }
 150          
 151          void key_control()
 152          {
 153   1        switch(key_scan()) 
 154   1          {
 155   2            case 1:
 156   2              set_display(current_time_config_index);
 157   2              break;
 158   2      
 159   2            case 2:
 160   2              set_display(current_turn_config);
 161   2              break;
 162   2            
 163   2            case 3:
 164   2              set_display(tune_time);
 165   2              break;
 166   2      
 167   2            case 8:        //换模式
 168   2            {
 169   3              // // 循环切换速度
 170   3              // current_time_config_index++;
 171   3              // if(current_time_config_index>=sizeof(speed_level_configs)/sizeof(struct time_config))
 172   3              //  current_time_config_index = 0;
 173   3              // load_time_config(current_time_config_index);
 174   3              current_schdule_config++;
 175   3              if(current_schdule_config>=sizeof(schdule_configs)/sizeof(struct schdule_config)){
 176   4                current_schdule_config = 0;
 177   4              }
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 12:47:24 PAGE 4   

 178   3              set_display(current_schdule_config);
 179   3              mode_low = schdule_configs[current_schdule_config].adjust_time_config;
 180   3              mode_high = schdule_configs[current_schdule_config].straight_time_config;
 181   3              break;
 182   3              // page--;
 183   3              // if(page<1) page=1;
 184   3              // set_display(page);
 185   3              // break;
 186   3            }
 187   2            // 开始、暂停、继续
 188   2            case 9:
 189   2            {
 190   3              TR0 = !TR0; 
 191   3              TR1 = TR0; 
 192   3              set_display(TR0*(current_time_config_index));
 193   3              IN1_1 = 0;
 194   3              IN1_2 = 0;
 195   3              IN2_1 = 0;
 196   3              IN2_2 = 0;
 197   3              tune_time = 0;
 198   3              runtime = 0;
 199   3              break;
 200   3            }
 201   2          }
 202   1      }
 203          
 204          
 205          void init()
 206          {
 207   1        EA=1;
 208   1        TMOD=0x11;      //配置为定时器0 8位重装模式，定时器1为16位定时器
 209   1        
 210   1        TH0=(65536-TIMER0)/256;                 //12M，定时50us
 211   1        TL0=(65536-TIMER0)%256;
 212   1        ET0=1;
 213   1        TR0=0;
 214   1      
 215   1        TH1=(65536-2000)/256;                 //12M，定时2ms
 216   1        TL1=(65536-2000)%256;
 217   1        ET1=1;
 218   1        TR1=0;
 219   1        
 220   1        // T2CON = 0;  //0000 0000   ;定时器2配置为16位自动重装定时器
 221   1        // RCAP2H = _iror_(65536-250,8);
 222   1        // RCAP2L = 65536-250;
 223   1        // TH2 = _iror_(65536-250,8);
 224   1        // TL2 = 65536-250;
 225   1        // ET2 = 1;
 226   1        // TR2 = 0;
 227   1        
 228   1        TRIG = 0;
 229   1        ECHO = 1;
 230   1        SIG1 = 0;
 231   1        BUZZER = 1;
 232   1        IN1_1 = 0;
 233   1        IN1_2 = 0;
 234   1        IN2_1 = 0;
 235   1        IN2_2 = 0;
 236   1        current_time_config = &speed_level_configs[0];
 237   1        mode_low = schdule_configs[current_schdule_config].adjust_time_config;
 238   1        mode_high = schdule_configs[current_schdule_config].straight_time_config;
 239   1        //eeprom_init();
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 12:47:24 PAGE 5   

 240   1        set_display(0);
 241   1      }
 242          
 243          void straight() //走直线
 244          {
 245   1        // 切换配置
 246   1        // 由于比较耗时，所以判断一下当前模式是值得的
 247   1        if(runtime > tune_time){
 248   2          if(current_time_config_index!=mode_high){
 249   3      
 250   3          }
 251   2            load_time_config(mode_high);
 252   2        }
 253   1        pro_left  = (*current_time_config).lstraight;
 254   1        pro_right = (*current_time_config).rstraight;
 255   1      }
 256          
 257          void turn_left() //左修正
 258          {
 259   1      
 260   1        pro_left  = (*current_time_config).lturn_left;
 261   1        pro_right = (*current_time_config).rturn_left;
 262   1        
 263   1      //  if((runtime>tune_time)&&(current_time_config_index!=mode_low)){
 264   1      //    load_time_config(mode_low);
 265   1      //    
 266   1      //    tune_time = runtime + ADJUST_TIME_SHORT;
 267   1      //  }else{
 268   1      //    pro_left  = (*current_time_config).lturn_left;
 269   1      //    pro_right = (*current_time_config).rturn_left;
 270   1      //  }
 271   1      }
 272          
 273          void turn_right() //右修正
 274          {
 275   1        pro_left  = (*current_time_config).lturn_right;
 276   1        pro_right = (*current_time_config).rturn_right;
 277   1        
 278   1      //  if((runtime>tune_time)&&(current_time_config_index!=mode_low)){
 279   1      //    load_time_config(mode_low);
 280   1      //    tune_time = runtime + ADJUST_TIME_SHORT;
 281   1      //  }else{
 282   1      //    pro_left  = (*current_time_config).lturn_right;
 283   1      //    pro_right = (*current_time_config).rturn_right;
 284   1      //  }
 285   1      }
 286          
 287          void turn_left_max() // 大幅度左修正
 288          {
 289   1        
 290   1        if(runtime>tune_time){
 291   2          if(current_time_config_index!=mode_low){
 292   3            slight_stop();
 293   3            load_time_config(mode_low);
 294   3            tune_time = runtime + ADJUST_TIME_LONG;
 295   3          }
 296   2        }else{
 297   2          pro_left  = (*current_time_config).lturn_left_max;
 298   2          pro_right = (*current_time_config).rturn_left_max;
 299   2        }
 300   1      }
 301          
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 12:47:24 PAGE 6   

 302          void turn_right_max() // 大幅度右修正
 303          {
 304   1        if(runtime>tune_time){
 305   2          if(current_time_config_index!=mode_low){
 306   3            slight_stop();
 307   3            load_time_config(mode_low);
 308   3            tune_time = runtime + ADJUST_TIME_LONG;
 309   3          }
 310   2        }else{
 311   2          pro_left  = (*current_time_config).lturn_right_max;
 312   2          pro_right = (*current_time_config).rturn_right_max;
 313   2        }
 314   1      }
 315          
 316          //左转90度
 317          void turn_left_90() 
 318          {
 319   1        unsigned int i=(*current_time_config).ltime;         //转过度减少时间，没转够增加时间
 320   1        while(i--)
 321   1        {
 322   2          // 右电机正转，  左电机反转
 323   2          if(i%4) IN2_1 = 1,IN1_2 =1;   //降低转弯速度,便于控制
 324   2          else IN2_1 = 0,IN1_2 =0;
 325   2        }
 326   1        IN2_1 = 0;
 327   1        IN1_2 = 0;
 328   1      }
 329          
 330          // 左转弯实现
 331          // 左电机正转，右电机反转 加快转弯速度
 332          void turn_right_90() //右转90度
 333          {
 334   1        unsigned int i=(*current_time_config).rtime;         //转过度减少时间，没转够增加时间
 335   1        while(i--)
 336   1        {
 337   2          if(i%4) IN1_1 = 1,IN2_2 =1;   //降低转弯速度,便于控制
 338   2          else IN1_1 = 0,IN2_2 =0;
 339   2        }
 340   1        IN1_1 = 0;
 341   1        IN2_2 = 0;
 342   1      }
 343          
 344          void go_straight()
 345          {
 346   1        unsigned int i=5000;
 347   1        while(i--)
 348   1        {
 349   2          if(i%4) IN1_1 = 1,IN2_1 =1;   //降低速度,便于控制
 350   2          else IN1_1 = 0,IN2_1 =0;
 351   2        }
 352   1        IN1_1 = 0;
 353   1        IN2_1 = 0;
 354   1      }
 355          
 356          void stop()
 357          {
 358   1        unsigned int i,j=0;
 359   1        // 防止中断函数导致停止失败
 360   1        for(i=5;i>1;i--) wait();
 361   1        while(1){
 362   2          key_control();
 363   2          set_display(j++);
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 12:47:24 PAGE 7   

 364   2          for(i=500;i>1;i--){
 365   3            delay(10);
 366   3            BUZZER = !BUZZER;
 367   3          } 
 368   2        }
 369   1      }
 370          
 371          void slight_stop(){
 372   1        unsigned int i = 500;         //转过度减少时间，没转够增加时间
 373   1        while(i--)
 374   1        {
 375   2          // 右电机正转，  左电机反转
 376   2          if(i%4) IN2_2 = 1,IN1_2 =1;   //降低转弯速度,便于控制
 377   2          else IN1_1 = 0,IN1_2 =0;
 378   2        }
 379   1        IN2_1 = 0;
 380   1        IN2_2 = 0;
 381   1      }
 382          
 383          /**
 384           *    十字路口处理程序
 385           *    1、停止当前调整动作
 386           *    2、测距
 387           *    3、判断应该【到终点、左90°转、右90转、直行】
 388           *    4、结束后恢复定时器
 389           */
 390          void crossroad()
 391          {
 392   1        if(XUNJI_1 && XUNJI_2 && XUNJI_3 && XUNJI_4)  //依旧四灯全灭,有理由相信遇到十字路口
 393   1        {
 394   2          wait();
 395   2          if(current_turn_config<sizeof(turn_configs)){
 396   3            if(turn_configs[current_turn_config]==LEFT){
 397   4              turn_left_90();
 398   4              go_straight();
 399   4              TR0 = 1;   //开启T0中断
 400   4              TR1 = 1;   //开启T1中断
 401   4            }else if(turn_configs[current_turn_config]==RIGHT){
 402   4              turn_right_90();
 403   4              go_straight();
 404   4              TR0 = 1;   //开启T0中断
 405   4              TR1 = 1;   //开启T1中断
 406   4            }else if(turn_configs[current_turn_config]==STRAIGHT){
 407   4              // 快速直行走出十字路口区域
 408   4              go_straight();
 409   4              TR0 = 1;   //开启T0中断
 410   4              TR1 = 1;   //开启T1中断
 411   4            }
 412   3          }else{
 413   3            stop();
 414   3            current_turn_config = 0;
 415   3          }
 416   2          current_turn_config++;
 417   2          set_display(current_turn_config);
 418   2        }
 419   1      }
 420          
 421          void wait() //暂停
 422          {
 423   1        TR1 = 0;
 424   1        TR0 = 0;
 425   1        time = 0;
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 12:47:24 PAGE 8   

 426   1        tune_time = 0;
 427   1        runtime = 0;
 428   1        pro_left = 0;
 429   1        pro_right = 0;
 430   1        IN1_1 = IN1_2 = IN2_1 = IN2_2 = 0;
 431   1      }
 432          /**
 433           *    循迹1、2、3、4 对应 左、左中、右中、右
 434           *    地面为白色时，灯亮，端口电平->低
 435           *    地面为黑色时，灯灭，端口电平->高
 436           *    左边灯灭，
 437           */
 438          void infrared() //循迹
 439          {
 440   1        //四灯全灭,可能遇到十字路口
 441   1        if(XUNJI_1 && XUNJI_2 && XUNJI_3 && XUNJI_4)
 442   1          crossroad();
 443   1        //严重偏右
 444   1        else if(XUNJI_1)
 445   1          turn_left_max();
 446   1        //严重偏左
 447   1        else if(XUNJI_4)
 448   1          turn_right_max();
 449   1        //中间
 450   1        else if(XUNJI_2 && XUNJI_3)
 451   1          straight();
 452   1        //偏右 (注：在严重偏右后面，即不发生严重偏右)
 453   1        else if(XUNJI_2)
 454   1          turn_left();
 455   1        //偏左 (注：在严重偏左后面，即不发生严重偏左)
 456   1        else if(XUNJI_3)
 457   1          turn_right();
 458   1        else
 459   1          straight();
 460   1          
 461   1      }
 462          
 463          // PWM 输出
 464          //电机输出函数
 465          void output()
 466          {
 467   1        if(time > 29)
 468   1        {
 469   2          time = 0;
 470   2          // 直行
 471   2          IN1_1 =1; IN2_1 = 1;
 472   2          IN1_2 =0; IN2_2 = 0;
 473   2          // 计时器 20*100us = 2 ms
 474   2          // 清零防止 tune_time > runtime 导致模式不能切换 
 475   2          if(runtime++==0)tune_time=0;
 476   2        }
 477   1        
 478   1        if(time == pro_left)  IN1_1 = 0;
 479   1        if(time == pro_right) IN2_1 = 0;
 480   1      }
 481          
 482          void set_display(unsigned char digit){
 483   1        display = segdata [digit%10];
 484   1      }
 485          
 486          void set_display_now(){
 487   1        A=BX=C=D=E=F=G=0;
C51 COMPILER V9.57.0.0   XUNJI                                                             07/01/2018 12:47:24 PAGE 9   

 488   1        A = display&0x01;
 489   1        BX = display&0x02;
 490   1        C = display&0x04;
 491   1        D = display&0x08;
 492   1        E = display&0x10;
 493   1        F = display&0x20;
 494   1        G = display&0x40;
 495   1      }
 496          
 497          // 读取预设参数，快速设置参数
 498          void load_time_config(char idx){
 499   1        current_time_config_index = idx;
 500   1        current_time_config = &speed_level_configs + current_time_config_index;
 501   1        set_display(current_time_config_index);
 502   1      }
 503          
 504          // 检测轮子状态
 505          void get_wheel_steps(){
 506   1        static unsigned int last_left = 1, last_right = 1;
 507   1        if(CESU_1 != last_left){left_steps++; last_left=CESU_1;} 
 508   1        if(CESU_2 != last_right){set_display(right_steps++); last_right=CESU_2;} 
 509   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1245    ----
   CONSTANT SIZE    =    132    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     28       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
