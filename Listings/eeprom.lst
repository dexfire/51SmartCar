C51 COMPILER V9.57.0.0   EEPROM                                                            06/24/2018 19:55:27 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE EEPROM
OBJECT MODULE PLACED IN .\Objects\eeprom.obj
COMPILER INVOKED BY: D:\Software\Keil_v5\C51\BIN\C51.EXE eeprom.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\eeprom.lst) TABS(2) OBJECT(.\Objects\eeprom.obj)

line level    source

   1          #include "eeprom.h"
   2          #include <intrins.h>
   3          
   4          // 对相关寄存器进行初始化
   5          void eeprom_init(){
   6   1          // 启用EEPROM读写
   7   1          ISP_CONTR &= 0x80;
   8   1          // 设置擦除等待时间
   9   1          ISP_CONTR &= 0x02;
  10   1      }
  11          
  12          // 从EEPROM读取一个字节
  13          unsigned char eeprom_read_byte(unsigned int offset){
  14   1          ISP_ADDRH = (offset + EEPROM_OFFSET)/256;
  15   1          // 直接赋值，高位会被舍弃
  16   1          ISP_ADDRL = offset + EEPROM_OFFSET;
  17   1          // 0x01 读 0x02 写 0x03 擦除
  18   1          ISP_CMD = 0x01;
  19   1          // 开始读取 Trigger - 扳机
  20   1          ISP_TRIG = 0x46;
  21   1          ISP_TRIG = 0xB9;
  22   1          return ISP_DATA;
  23   1      }
  24          
  25          // 从EEPROM读取数据，返回读取的内容,可以连续读入
  26          unsigned char* eeprom_read(unsigned int offset,unsigned char *buffer,unsigned int buffer_offset,unsigned i
             -nt len){
  27   1          unsigned int i;
  28   1          ISP_CMD = 0x01;
  29   1          for(i=0;i<len;i++){
  30   2              ISP_ADDRH = _iror_(EEPROM_OFFSET + offset + i,8);
  31   2              ISP_ADDRL = EEPROM_OFFSET + offset + i;
  32   2              ISP_TRIG = 0x46;
  33   2              ISP_TRIG = 0xB9;
  34   2              *(buffer+buffer_offset+i) = ISP_DATA;
  35   2          }
  36   1          return buffer;
  37   1      }
  38          
  39          void eeprom_write_byte(unsigned int offset,unsigned char byte){
  40   1          ISP_ADDRH = _iror_(offset + EEPROM_OFFSET,8);
  41   1          // 直接赋值，高位会被舍弃
  42   1          ISP_ADDRL = offset + EEPROM_OFFSET;
  43   1          // 0x01 读 0x02 写 0x03 擦除
  44   1          ISP_CMD = 0x02;
  45   1          ISP_DATA = byte;
  46   1          // 开始读取 Trigger - 扳机
  47   1          ISP_TRIG = 0x46;
  48   1          ISP_TRIG = 0xB9;
  49   1      }
  50          
  51          // 写入数据，一次性最多写入 512 bytes
  52          void eeprom_write(unsigned int offset,unsigned char *buffer,unsigned int buffer_offset,unsigned int len){
  53   1          unsigned int i;
C51 COMPILER V9.57.0.0   EEPROM                                                            06/24/2018 19:55:27 PAGE 2   

  54   1          ISP_CMD = 0x02;
  55   1          for(i=0;i<len;i++){
  56   2              ISP_ADDRH = _iror_(EEPROM_OFFSET + offset + i,8);
  57   2              ISP_ADDRL = EEPROM_OFFSET + offset + i;
  58   2              ISP_DATA = *(buffer+buffer_offset+i);
  59   2              // 提交写入命令
  60   2              ISP_TRIG = 0x46;
  61   2              ISP_TRIG = 0xB9;
  62   2          }
  63   1      }
  64          
  65          // 对于STC89C52RC来说，idx = [0:7];
  66          void eeprom_erase(unsigned char idx){
  67   1          ISP_ADDRH = _iror_(EEPROM_OFFSET + idx * EEPROM_SECTOR_SIZE,8);
  68   1          ISP_ADDRL = EEPROM_OFFSET + idx * EEPROM_SECTOR_SIZE;
  69   1          ISP_CMD = 0x03;
  70   1          ISP_TRIG = 0x46;
  71   1          ISP_DATA = 0xB9;
  72   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    312    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
